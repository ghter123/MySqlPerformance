表结构是数据库的基石，合理的设计是高性能的基础。
# 数据类型设计原则

## 数据类型对性能的影响因素

我们知道任何数据在数据库中一般会参与两件事：存储和计算。不同的数据类型，存储需要的空间、存储的策略、是否原生支持CPU计算这些行为都不同，对性能都会产生影响。

### 存储

空间上，类型需要越大的存储空间意味着占用更多的磁盘、内存、CPU缓存和CPU计算周期。

### 计算

这里说的计算是数据库对数据的处理，主要是查询，函数运算等等。
1. 越简单的数据类型消耗越少的CPU计算周期。比如整形比字符串型更简单，因为字符串有更复杂的排序规则，存储一个IP地址用整形比字符串类型好。
2. CPU原生支持的数据类型消耗越少的CPU计算周期。比如CPU原生支持double运算，而decimal则需要mysql的编码层面支持，数据量大的情况下效率是差距比较大的。

## 数据类型的设计原则

基于上面两点我们应该很容易总结出一个大方向规则：越小越好、越简单越好、对CPU越友好越好。下面是一些具体的例子。

1. 善用不定长类型（var前缀）。var是不定长的，好处是它只使用真正的需要的存储空间和额外的长度字节（小于等于255是1字节，大于是2字节）。坏处是在更新的时候如果字符串变长了，有可能需要做额外的增长空间的工作，如果页内空间不足，甚至要分裂页。
2. 善用TimeStamp。这个类型只需要DateTime一般的存储空间，很多应用场景能起到和DateTime一样的效果。但是如果你要使用它，请对它们两者有足够的了解。
3. 善用枚举类型。枚举类型在Mysql存储为整型。整型相比字符串有巨大的优势。如果一个列是在一个有限比较小的字符串范围内选择值，那么可以考虑用枚举类型代替字符串类型。
4. 善用not null。null在mysql中需要特殊的处理，会引入储存和索引上额外的复杂度。
5. 主键列尽量使用整型。不止是主键，关联列也应该尽量使用整型，这样在关联的时候可以有更好的性能。由其建立其它列索引时，通常都会带上主键列，这时候就更需要性能更好的整型了。
6. 慎用decimal。decimal是一种复杂类型。在可以用整型或者浮点型代替的情况下，应当使用后两者。

# 范式和反范式

## 范式

首先回顾一下关系型数据的三大范式:

1. 没有重复的列：一个属性不能有多个值。
2. 满足1 + 必须有主键：每行数据必须能被某个列唯一区分。
3. 满足1、2 + 外键必须是主键：必须依赖其它表的主键。

这三个基本范式是为了消除冗余信息，你可以理解为满足越多的范式就是拥有越少的冗余。

## 反范式

顾名思义就是违反范式，增加适当的冗余信息。比如常见的标签属性，一般都是将标签原文直接打在该属性上，该列一般会有多个值。反范式的好处是有适当的冗余信息可以减少关联查询和建立更有效的索引，坏处是增加实现的复杂度（数据同步等）。

## 混用范式和反范式

满足范式可以得到最少冗余，反范式可以提高一些操作的性能（一般是查询）。所以原则上我们应该优先满足范式，在特殊的场景和性能要求下再去添加冗余信息。比如说上面说的标签，如果要符合三大范式，需要三个表：产品表，标签表，产品标签关联表。要展示一个产品的所有标签信息需要关联三张表，如果采用反范式设计，则只需要查询产品表，这就是所谓的减少关联；又比如，要查询某个类型的所有用户金额最大的十个消费记录，如果是范式设计，而且消费表的金额有索引，那么查询可能是倒序遍历金额索引再关联查询这个用户是否符合这个类型，或者是先将类型用户查询来，再去搜索消费表所有该类型用户的记录再倒序取前十。如果采用反范式设计，我们可以在消费表加入该用户的类型字段，再建立用户类型和消费金额的联合索引，那么该查询效率将有巨大的提升。这就是所谓的建立更有效的索引。

# 善用扩展表

创建一些特殊功能的表很多时候都是一个有效的优化操作效率的策略，比较通用的有一下三种。

## 缓存表

顾名思义就是缓存了别的表的内容，而这些内容直接通过其它表获取起来又比较慢。

## 统计表

顾名思义就是储存统计计算结果的表。

## 计数器表

用于统计计数的表。举个列子，需要统计一个网站的总访问量，那么就可以如下实现。

```` sql
/** 表结构 **/
create table hit_counter(
    /** 为实现并发设置的slot **/
    slot tinyint unsigned not null primary key,
    /** 点击数量 **/
    cnt int unsigned not null
) engine = InnoDB;

/** 更新操作 **/
/** 预先设置20个slot,选择一个随机的slot更新cnt **/
update hit_counter set cnt = cnt + 1 where slot = rand() * 20;

/** 获取总访问量 **/
select sum(cnt) from hit_counter;
````